# Pareto-aware Neural Architecture Generation for Diverse Computational Budgets

![](https://img.shields.io/badge/-PyTorch%20Implementation-blue.svg?logo=pytorch)
![](https://img.shields.io/badge/license-MIT-blue.svg)

## Introduction

Designing feasible and effective architectures under diverse computational budgets, incurred by different applications/devices, is essential for deploying deep models in practice.
To achieve this goal, existing methods often perform an independent architecture search process for each target budget, which is very inefficient yet unnecessary.
More critically, these independent search processes cannot share their learned knowledge (i.e., the distribution of good architectures) with each other and thus often result in limited search results.
To address these issues, we propose a Pareto-aware Neural Architecture Generator (PNAG) which only needs to be trained once and automatically produces the Pareto optimal architecture for any given budget via inference (See Figure 1 (a)).
To train the PNAG, we learn the whole Pareto frontier by jointly finding multiple Pareto optimal architectures under diverse computational budgets (See Figure 1 (b)). 
Such a joint search algorithm not only greatly reduces the overall search cost but also improves the search performance.
Extensive experiments on three platforms (i.e., mobile device, CPU, and GPU) show the superiority of our method over existing methods.

<p align="center">
<img src="assets/pnag_illustration.png" alt="PNAG" width="95%" align=center />
</p>


<p align="center">
<i>
Figure 1.
An illustration of how to apply our PNAG to generate feasible architectures for diverse computational budgets (a) and the comparisons between PNAG and conventional NAS methods (b). (a) PNAG takes an arbitrary budget as input and flexibly generates feasible architectures.
(b) PNAG learns the whole Pareto frontier rather than finding discrete architectures.
</i>
</p>

## Performance Results

We compare PNAG with state-of-the-art methods on mobile device (Snapdragon 821), CPU devices (i5-7400), and GPU devices (NVIDIA TITAN X GPU). 
From Figure 2, our PNAG consistently achieves higher accuracy than other methods. 
PNAG outperforms state-of-the-art architectures under different latency budgets. 
Specifically, given any latency budget, the architectures generated by PNAG consistently yield better performance than the considered baseline methods, including OFA and OFA-MO.
More critically, our PNAG only need to search once to produce promising architectures that satisfy different latency budgets accordingly, while previous methods need to repeat the search process according to different budgets.
These results show the effectiveness of our PNAG on three considered devices.

<p align="center">
<img src="assets/nag_compare_sota.png" alt="PNAG" width="95%" align=center />
</p>


<p align="center">
<i>
Figure 2.
Comparisons of the architectures obtained by different methods on mobile, CPU and GPU devices.
</i>
</p>

## Requirements

Please install all the requirements in `requirements.txt`.

## Datasets

We consider a large-scale benchmark classification datsets, namely ImageNet.

ImageNet needs to be manually downloaded (preferably to a SSD) and preprocessed following the [instructions](https://github.com/pytorch/examples/tree/master/imagenet).

## Training Method

We have collect the validation accuracy, the latency on CPU (Intel i5-7400), GPU (NVIDIA TITAN X) and mobile phone (equipped with a Qualcomm Snapdragon 821 processor) of 16,000 architectures in the file (`data/architectures.json`).
The following scripts will search architectures with the collected data.

Script to search on CPU platform.
```
bash entry/search_on_cpu.sh /path/to/imagenet
```

Script to search on GPU platform.
```
bash entry/search_on_gpu.sh /path/to/imagenet
```

Script to search on mobile platform.
```
bash entry/search_on_mobile.sh /path/to/imagenet
```

## Evaluation Method

 - Pretrained models
 
We have released our PNAG ImageNet pretrained model on [here](https://github.com/guoyongcs/PNAG/releases/tag/weights).

You can use the following codes to load the pretrained models:

```
import torch
model = torch.hub.load("github.com/guoyongcs/PNAG", "pnag-cpu-30")
```

All available model names are

```
['pnag_cpu_30', 'pnag_cpu_35', 'pnag_cpu_40', 'pnag_cpu_45', 'pnag_cpu_50', 
'pnag_gpu_90', 'pnag_gpu_115', 'pnag_gpu_140', 'pnag_gpu_165', 'pnag_gpu_190', 
'pnag_mobile_80', 'pnag_mobile_110', 'pnag_mobile_140', 'pnag_mobile_170', 'pnag_mobile_200',]
```

 - Evaluating pretrained models on ImageNet

```
python -m entry.eval /path/to/imagenet
```

Results:
```
pnag_cpu_30, top1_acc=78.26%, top5_acc=94.07%
pnag_cpu_35, top1_acc=79.39%, top5_acc=94.45%
pnag_cpu_40, top1_acc=79.72%, top5_acc=94.86%
pnag_cpu_45, top1_acc=80.26%, top5_acc=95.03%
pnag_cpu_50, top1_acc=80.47%, top5_acc=95.05%
pnag_gpu_90, top1_acc=78.24%, top5_acc=93.98%
pnag_gpu_115, top1_acc=79.32%, top5_acc=94.56%
pnag_gpu_140, top1_acc=79.70%, top5_acc=94.82%
pnag_gpu_165, top1_acc=80.18%, top5_acc=94.98%
pnag_gpu_190, top1_acc=80.46%, top5_acc=95.02%
pnag_mobile_80, top1_acc=78.31%, top5_acc=93.97%
pnag_mobile_110, top1_acc=79.39%, top5_acc=94.51%
pnag_mobile_170, top1_acc=80.35%, top5_acc=95.01%
pnag_mobile_200, top1_acc=80.43%, top5_acc=95.17%
```